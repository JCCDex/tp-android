/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/MateMask.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/asap/browser-asap.js":
/*!*******************************************!*\
  !*** ./node_modules/asap/browser-asap.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// rawAsap provides everything we need except exception management.\nvar rawAsap = __webpack_require__(/*! ./raw */ \"./node_modules/asap/browser-raw.js\");\n// RawTasks are recycled to reduce GC churn.\nvar freeTasks = [];\n// We queue errors to ensure they are thrown in right order (FIFO).\n// Array-as-queue is good enough here, since we are just dealing with exceptions.\nvar pendingErrors = [];\nvar requestErrorThrow = rawAsap.makeRequestCallFromTimer(throwFirstError);\n\nfunction throwFirstError() {\n    if (pendingErrors.length) {\n        throw pendingErrors.shift();\n    }\n}\n\n/**\n * Calls a task as soon as possible after returning, in its own event, with priority\n * over other events like animation, reflow, and repaint. An error thrown from an\n * event will not interrupt, nor even substantially slow down the processing of\n * other events, but will be rather postponed to a lower priority event.\n * @param {{call}} task A callable object, typically a function that takes no\n * arguments.\n */\nmodule.exports = asap;\nfunction asap(task) {\n    var rawTask;\n    if (freeTasks.length) {\n        rawTask = freeTasks.pop();\n    } else {\n        rawTask = new RawTask();\n    }\n    rawTask.task = task;\n    rawAsap(rawTask);\n}\n\n// We wrap tasks with recyclable task objects.  A task object implements\n// `call`, just like a function.\nfunction RawTask() {\n    this.task = null;\n}\n\n// The sole purpose of wrapping the task is to catch the exception and recycle\n// the task object after its single use.\nRawTask.prototype.call = function () {\n    try {\n        this.task.call();\n    } catch (error) {\n        if (asap.onerror) {\n            // This hook exists purely for testing purposes.\n            // Its name will be periodically randomized to break any code that\n            // depends on its existence.\n            asap.onerror(error);\n        } else {\n            // In a web browser, exceptions are not fatal. However, to avoid\n            // slowing down the queue of pending tasks, we rethrow the error in a\n            // lower priority turn.\n            pendingErrors.push(error);\n            requestErrorThrow();\n        }\n    } finally {\n        this.task = null;\n        freeTasks[freeTasks.length] = this;\n    }\n};\n\n\n//# sourceURL=webpack:///./node_modules/asap/browser-asap.js?");

/***/ }),

/***/ "./node_modules/asap/browser-raw.js":
/*!******************************************!*\
  !*** ./node_modules/asap/browser-raw.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {\n\n// Use the fastest means possible to execute a task in its own turn, with\n// priority over other events including IO, animation, reflow, and redraw\n// events in browsers.\n//\n// An exception thrown by a task will permanently interrupt the processing of\n// subsequent tasks. The higher level `asap` function ensures that if an\n// exception is thrown by a task, that the task queue will continue flushing as\n// soon as possible, but if you use `rawAsap` directly, you are responsible to\n// either ensure that no exceptions are thrown from your task, or to manually\n// call `rawAsap.requestFlush` if an exception is thrown.\nmodule.exports = rawAsap;\nfunction rawAsap(task) {\n    if (!queue.length) {\n        requestFlush();\n        flushing = true;\n    }\n    // Equivalent to push, but avoids a function call.\n    queue[queue.length] = task;\n}\n\nvar queue = [];\n// Once a flush has been requested, no further calls to `requestFlush` are\n// necessary until the next `flush` completes.\nvar flushing = false;\n// `requestFlush` is an implementation-specific method that attempts to kick\n// off a `flush` event as quickly as possible. `flush` will attempt to exhaust\n// the event queue before yielding to the browser's own event loop.\nvar requestFlush;\n// The position of the next task to execute in the task queue. This is\n// preserved between calls to `flush` so that it can be resumed if\n// a task throws an exception.\nvar index = 0;\n// If a task schedules additional tasks recursively, the task queue can grow\n// unbounded. To prevent memory exhaustion, the task queue will periodically\n// truncate already-completed tasks.\nvar capacity = 1024;\n\n// The flush function processes all tasks that have been scheduled with\n// `rawAsap` unless and until one of those tasks throws an exception.\n// If a task throws an exception, `flush` ensures that its state will remain\n// consistent and will resume where it left off when called again.\n// However, `flush` does not make any arrangements to be called again if an\n// exception is thrown.\nfunction flush() {\n    while (index < queue.length) {\n        var currentIndex = index;\n        // Advance the index before calling the task. This ensures that we will\n        // begin flushing on the next task the task throws an error.\n        index = index + 1;\n        queue[currentIndex].call();\n        // Prevent leaking memory for long chains of recursive calls to `asap`.\n        // If we call `asap` within tasks scheduled by `asap`, the queue will\n        // grow, but to avoid an O(n) walk for every task we execute, we don't\n        // shift tasks off the queue after they have been executed.\n        // Instead, we periodically shift 1024 tasks off the queue.\n        if (index > capacity) {\n            // Manually shift all values starting at the index back to the\n            // beginning of the queue.\n            for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {\n                queue[scan] = queue[scan + index];\n            }\n            queue.length -= index;\n            index = 0;\n        }\n    }\n    queue.length = 0;\n    index = 0;\n    flushing = false;\n}\n\n// `requestFlush` is implemented using a strategy based on data collected from\n// every available SauceLabs Selenium web driver worker at time of writing.\n// https://docs.google.com/spreadsheets/d/1mG-5UYGup5qxGdEMWkhP6BWCz053NUb2E1QoUTU16uA/edit#gid=783724593\n\n// Safari 6 and 6.1 for desktop, iPad, and iPhone are the only browsers that\n// have WebKitMutationObserver but not un-prefixed MutationObserver.\n// Must use `global` or `self` instead of `window` to work in both frames and web\n// workers. `global` is a provision of Browserify, Mr, Mrs, or Mop.\n\n/* globals self */\nvar scope = typeof global !== \"undefined\" ? global : self;\nvar BrowserMutationObserver = scope.MutationObserver || scope.WebKitMutationObserver;\n\n// MutationObservers are desirable because they have high priority and work\n// reliably everywhere they are implemented.\n// They are implemented in all modern browsers.\n//\n// - Android 4-4.3\n// - Chrome 26-34\n// - Firefox 14-29\n// - Internet Explorer 11\n// - iPad Safari 6-7.1\n// - iPhone Safari 7-7.1\n// - Safari 6-7\nif (typeof BrowserMutationObserver === \"function\") {\n    requestFlush = makeRequestCallFromMutationObserver(flush);\n\n// MessageChannels are desirable because they give direct access to the HTML\n// task queue, are implemented in Internet Explorer 10, Safari 5.0-1, and Opera\n// 11-12, and in web workers in many engines.\n// Although message channels yield to any queued rendering and IO tasks, they\n// would be better than imposing the 4ms delay of timers.\n// However, they do not work reliably in Internet Explorer or Safari.\n\n// Internet Explorer 10 is the only browser that has setImmediate but does\n// not have MutationObservers.\n// Although setImmediate yields to the browser's renderer, it would be\n// preferrable to falling back to setTimeout since it does not have\n// the minimum 4ms penalty.\n// Unfortunately there appears to be a bug in Internet Explorer 10 Mobile (and\n// Desktop to a lesser extent) that renders both setImmediate and\n// MessageChannel useless for the purposes of ASAP.\n// https://github.com/kriskowal/q/issues/396\n\n// Timers are implemented universally.\n// We fall back to timers in workers in most engines, and in foreground\n// contexts in the following browsers.\n// However, note that even this simple case requires nuances to operate in a\n// broad spectrum of browsers.\n//\n// - Firefox 3-13\n// - Internet Explorer 6-9\n// - iPad Safari 4.3\n// - Lynx 2.8.7\n} else {\n    requestFlush = makeRequestCallFromTimer(flush);\n}\n\n// `requestFlush` requests that the high priority event queue be flushed as\n// soon as possible.\n// This is useful to prevent an error thrown in a task from stalling the event\n// queue if the exception handled by Node.jsâ€™s\n// `process.on(\"uncaughtException\")` or by a domain.\nrawAsap.requestFlush = requestFlush;\n\n// To request a high priority event, we induce a mutation observer by toggling\n// the text of a text node between \"1\" and \"-1\".\nfunction makeRequestCallFromMutationObserver(callback) {\n    var toggle = 1;\n    var observer = new BrowserMutationObserver(callback);\n    var node = document.createTextNode(\"\");\n    observer.observe(node, {characterData: true});\n    return function requestCall() {\n        toggle = -toggle;\n        node.data = toggle;\n    };\n}\n\n// The message channel technique was discovered by Malte Ubl and was the\n// original foundation for this library.\n// http://www.nonblocking.io/2011/06/windownexttick.html\n\n// Safari 6.0.5 (at least) intermittently fails to create message ports on a\n// page's first load. Thankfully, this version of Safari supports\n// MutationObservers, so we don't need to fall back in that case.\n\n// function makeRequestCallFromMessageChannel(callback) {\n//     var channel = new MessageChannel();\n//     channel.port1.onmessage = callback;\n//     return function requestCall() {\n//         channel.port2.postMessage(0);\n//     };\n// }\n\n// For reasons explained above, we are also unable to use `setImmediate`\n// under any circumstances.\n// Even if we were, there is another bug in Internet Explorer 10.\n// It is not sufficient to assign `setImmediate` to `requestFlush` because\n// `setImmediate` must be called *by name* and therefore must be wrapped in a\n// closure.\n// Never forget.\n\n// function makeRequestCallFromSetImmediate(callback) {\n//     return function requestCall() {\n//         setImmediate(callback);\n//     };\n// }\n\n// Safari 6.0 has a problem where timers will get lost while the user is\n// scrolling. This problem does not impact ASAP because Safari 6.0 supports\n// mutation observers, so that implementation is used instead.\n// However, if we ever elect to use timers in Safari, the prevalent work-around\n// is to add a scroll event listener that calls for a flush.\n\n// `setTimeout` does not call the passed callback if the delay is less than\n// approximately 7 in web workers in Firefox 8 through 18, and sometimes not\n// even then.\n\nfunction makeRequestCallFromTimer(callback) {\n    return function requestCall() {\n        // We dispatch a timeout with a specified delay of 0 for engines that\n        // can reliably accommodate that request. This will usually be snapped\n        // to a 4 milisecond delay, but once we're flushing, there's no delay\n        // between events.\n        var timeoutHandle = setTimeout(handleTimer, 0);\n        // However, since this timer gets frequently dropped in Firefox\n        // workers, we enlist an interval handle that will try to fire\n        // an event 20 times per second until it succeeds.\n        var intervalHandle = setInterval(handleTimer, 50);\n\n        function handleTimer() {\n            // Whichever timer succeeds will cancel both timers and\n            // execute the callback.\n            clearTimeout(timeoutHandle);\n            clearInterval(intervalHandle);\n            callback();\n        }\n    };\n}\n\n// This is for `asap.js` only.\n// Its name will be periodically randomized to break any code that depends on\n// its existence.\nrawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer;\n\n// ASAP was originally a nextTick shim included in Q. This was factored out\n// into this ASAP package. It was later adapted to RSVP which made further\n// amendments. These decisions, particularly to marginalize MessageChannel and\n// to capture the MutationObserver implementation in a closure, were integrated\n// back into ASAP proper.\n// https://github.com/tildeio/rsvp.js/blob/cddf7232546a9cf858524b75cde6f9edf72620a7/lib/rsvp/asap.js\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/asap/browser-raw.js?");

/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function eventListener() {\n      if (errorListener !== undefined) {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n    var errorListener;\n\n    // Adding an error listener is not optional because\n    // if an error is thrown on an event emitter we cannot\n    // guarantee that the actual event we are waiting will\n    // be fired. The result could be a silent way to create\n    // memory or file descriptor leaks, which is something\n    // we should avoid.\n    if (name !== 'error') {\n      errorListener = function errorListener(err) {\n        emitter.removeListener(name, eventListener);\n        reject(err);\n      };\n\n      emitter.once('error', errorListener);\n    }\n\n    emitter.once(name, eventListener);\n  });\n}\n\n\n//# sourceURL=webpack:///./node_modules/events/events.js?");

/***/ }),

/***/ "./node_modules/promise/index.js":
/*!***************************************!*\
  !*** ./node_modules/promise/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = __webpack_require__(/*! ./lib */ \"./node_modules/promise/lib/index.js\")\n\n\n//# sourceURL=webpack:///./node_modules/promise/index.js?");

/***/ }),

/***/ "./node_modules/promise/lib/core.js":
/*!******************************************!*\
  !*** ./node_modules/promise/lib/core.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar asap = __webpack_require__(/*! asap/raw */ \"./node_modules/asap/browser-raw.js\");\n\nfunction noop() {}\n\n// States:\n//\n// 0 - pending\n// 1 - fulfilled with _value\n// 2 - rejected with _value\n// 3 - adopted the state of another promise, _value\n//\n// once the state is no longer pending (0) it is immutable\n\n// All `_` prefixed properties will be reduced to `_{random number}`\n// at build time to obfuscate them and discourage their use.\n// We don't use symbols or Object.defineProperty to fully hide them\n// because the performance isn't good enough.\n\n\n// to avoid using try/catch inside critical functions, we\n// extract them to here.\nvar LAST_ERROR = null;\nvar IS_ERROR = {};\nfunction getThen(obj) {\n  try {\n    return obj.then;\n  } catch (ex) {\n    LAST_ERROR = ex;\n    return IS_ERROR;\n  }\n}\n\nfunction tryCallOne(fn, a) {\n  try {\n    return fn(a);\n  } catch (ex) {\n    LAST_ERROR = ex;\n    return IS_ERROR;\n  }\n}\nfunction tryCallTwo(fn, a, b) {\n  try {\n    fn(a, b);\n  } catch (ex) {\n    LAST_ERROR = ex;\n    return IS_ERROR;\n  }\n}\n\nmodule.exports = Promise;\n\nfunction Promise(fn) {\n  if (typeof this !== 'object') {\n    throw new TypeError('Promises must be constructed via new');\n  }\n  if (typeof fn !== 'function') {\n    throw new TypeError('Promise constructor\\'s argument is not a function');\n  }\n  this._U = 0;\n  this._V = 0;\n  this._W = null;\n  this._X = null;\n  if (fn === noop) return;\n  doResolve(fn, this);\n}\nPromise._Y = null;\nPromise._Z = null;\nPromise._0 = noop;\n\nPromise.prototype.then = function(onFulfilled, onRejected) {\n  if (this.constructor !== Promise) {\n    return safeThen(this, onFulfilled, onRejected);\n  }\n  var res = new Promise(noop);\n  handle(this, new Handler(onFulfilled, onRejected, res));\n  return res;\n};\n\nfunction safeThen(self, onFulfilled, onRejected) {\n  return new self.constructor(function (resolve, reject) {\n    var res = new Promise(noop);\n    res.then(resolve, reject);\n    handle(self, new Handler(onFulfilled, onRejected, res));\n  });\n}\nfunction handle(self, deferred) {\n  while (self._V === 3) {\n    self = self._W;\n  }\n  if (Promise._Y) {\n    Promise._Y(self);\n  }\n  if (self._V === 0) {\n    if (self._U === 0) {\n      self._U = 1;\n      self._X = deferred;\n      return;\n    }\n    if (self._U === 1) {\n      self._U = 2;\n      self._X = [self._X, deferred];\n      return;\n    }\n    self._X.push(deferred);\n    return;\n  }\n  handleResolved(self, deferred);\n}\n\nfunction handleResolved(self, deferred) {\n  asap(function() {\n    var cb = self._V === 1 ? deferred.onFulfilled : deferred.onRejected;\n    if (cb === null) {\n      if (self._V === 1) {\n        resolve(deferred.promise, self._W);\n      } else {\n        reject(deferred.promise, self._W);\n      }\n      return;\n    }\n    var ret = tryCallOne(cb, self._W);\n    if (ret === IS_ERROR) {\n      reject(deferred.promise, LAST_ERROR);\n    } else {\n      resolve(deferred.promise, ret);\n    }\n  });\n}\nfunction resolve(self, newValue) {\n  // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n  if (newValue === self) {\n    return reject(\n      self,\n      new TypeError('A promise cannot be resolved with itself.')\n    );\n  }\n  if (\n    newValue &&\n    (typeof newValue === 'object' || typeof newValue === 'function')\n  ) {\n    var then = getThen(newValue);\n    if (then === IS_ERROR) {\n      return reject(self, LAST_ERROR);\n    }\n    if (\n      then === self.then &&\n      newValue instanceof Promise\n    ) {\n      self._V = 3;\n      self._W = newValue;\n      finale(self);\n      return;\n    } else if (typeof then === 'function') {\n      doResolve(then.bind(newValue), self);\n      return;\n    }\n  }\n  self._V = 1;\n  self._W = newValue;\n  finale(self);\n}\n\nfunction reject(self, newValue) {\n  self._V = 2;\n  self._W = newValue;\n  if (Promise._Z) {\n    Promise._Z(self, newValue);\n  }\n  finale(self);\n}\nfunction finale(self) {\n  if (self._U === 1) {\n    handle(self, self._X);\n    self._X = null;\n  }\n  if (self._U === 2) {\n    for (var i = 0; i < self._X.length; i++) {\n      handle(self, self._X[i]);\n    }\n    self._X = null;\n  }\n}\n\nfunction Handler(onFulfilled, onRejected, promise){\n  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n  this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n  this.promise = promise;\n}\n\n/**\n * Take a potentially misbehaving resolver function and make sure\n * onFulfilled and onRejected are only called once.\n *\n * Makes no guarantees about asynchrony.\n */\nfunction doResolve(fn, promise) {\n  var done = false;\n  var res = tryCallTwo(fn, function (value) {\n    if (done) return;\n    done = true;\n    resolve(promise, value);\n  }, function (reason) {\n    if (done) return;\n    done = true;\n    reject(promise, reason);\n  });\n  if (!done && res === IS_ERROR) {\n    done = true;\n    reject(promise, LAST_ERROR);\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/promise/lib/core.js?");

/***/ }),

/***/ "./node_modules/promise/lib/done.js":
/*!******************************************!*\
  !*** ./node_modules/promise/lib/done.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar Promise = __webpack_require__(/*! ./core.js */ \"./node_modules/promise/lib/core.js\");\n\nmodule.exports = Promise;\nPromise.prototype.done = function (onFulfilled, onRejected) {\n  var self = arguments.length ? this.then.apply(this, arguments) : this;\n  self.then(null, function (err) {\n    setTimeout(function () {\n      throw err;\n    }, 0);\n  });\n};\n\n\n//# sourceURL=webpack:///./node_modules/promise/lib/done.js?");

/***/ }),

/***/ "./node_modules/promise/lib/es6-extensions.js":
/*!****************************************************!*\
  !*** ./node_modules/promise/lib/es6-extensions.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n//This file contains the ES6 extensions to the core Promises/A+ API\n\nvar Promise = __webpack_require__(/*! ./core.js */ \"./node_modules/promise/lib/core.js\");\n\nmodule.exports = Promise;\n\n/* Static Functions */\n\nvar TRUE = valuePromise(true);\nvar FALSE = valuePromise(false);\nvar NULL = valuePromise(null);\nvar UNDEFINED = valuePromise(undefined);\nvar ZERO = valuePromise(0);\nvar EMPTYSTRING = valuePromise('');\n\nfunction valuePromise(value) {\n  var p = new Promise(Promise._0);\n  p._V = 1;\n  p._W = value;\n  return p;\n}\nPromise.resolve = function (value) {\n  if (value instanceof Promise) return value;\n\n  if (value === null) return NULL;\n  if (value === undefined) return UNDEFINED;\n  if (value === true) return TRUE;\n  if (value === false) return FALSE;\n  if (value === 0) return ZERO;\n  if (value === '') return EMPTYSTRING;\n\n  if (typeof value === 'object' || typeof value === 'function') {\n    try {\n      var then = value.then;\n      if (typeof then === 'function') {\n        return new Promise(then.bind(value));\n      }\n    } catch (ex) {\n      return new Promise(function (resolve, reject) {\n        reject(ex);\n      });\n    }\n  }\n  return valuePromise(value);\n};\n\nvar iterableToArray = function (iterable) {\n  if (typeof Array.from === 'function') {\n    // ES2015+, iterables exist\n    iterableToArray = Array.from;\n    return Array.from(iterable);\n  }\n\n  // ES5, only arrays and array-likes exist\n  iterableToArray = function (x) { return Array.prototype.slice.call(x); };\n  return Array.prototype.slice.call(iterable);\n}\n\nPromise.all = function (arr) {\n  var args = iterableToArray(arr);\n\n  return new Promise(function (resolve, reject) {\n    if (args.length === 0) return resolve([]);\n    var remaining = args.length;\n    function res(i, val) {\n      if (val && (typeof val === 'object' || typeof val === 'function')) {\n        if (val instanceof Promise && val.then === Promise.prototype.then) {\n          while (val._V === 3) {\n            val = val._W;\n          }\n          if (val._V === 1) return res(i, val._W);\n          if (val._V === 2) reject(val._W);\n          val.then(function (val) {\n            res(i, val);\n          }, reject);\n          return;\n        } else {\n          var then = val.then;\n          if (typeof then === 'function') {\n            var p = new Promise(then.bind(val));\n            p.then(function (val) {\n              res(i, val);\n            }, reject);\n            return;\n          }\n        }\n      }\n      args[i] = val;\n      if (--remaining === 0) {\n        resolve(args);\n      }\n    }\n    for (var i = 0; i < args.length; i++) {\n      res(i, args[i]);\n    }\n  });\n};\n\nPromise.reject = function (value) {\n  return new Promise(function (resolve, reject) {\n    reject(value);\n  });\n};\n\nPromise.race = function (values) {\n  return new Promise(function (resolve, reject) {\n    iterableToArray(values).forEach(function(value){\n      Promise.resolve(value).then(resolve, reject);\n    });\n  });\n};\n\n/* Prototype Methods */\n\nPromise.prototype['catch'] = function (onRejected) {\n  return this.then(null, onRejected);\n};\n\n\n//# sourceURL=webpack:///./node_modules/promise/lib/es6-extensions.js?");

/***/ }),

/***/ "./node_modules/promise/lib/finally.js":
/*!*********************************************!*\
  !*** ./node_modules/promise/lib/finally.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar Promise = __webpack_require__(/*! ./core.js */ \"./node_modules/promise/lib/core.js\");\n\nmodule.exports = Promise;\nPromise.prototype.finally = function (f) {\n  return this.then(function (value) {\n    return Promise.resolve(f()).then(function () {\n      return value;\n    });\n  }, function (err) {\n    return Promise.resolve(f()).then(function () {\n      throw err;\n    });\n  });\n};\n\n\n//# sourceURL=webpack:///./node_modules/promise/lib/finally.js?");

/***/ }),

/***/ "./node_modules/promise/lib/index.js":
/*!*******************************************!*\
  !*** ./node_modules/promise/lib/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = __webpack_require__(/*! ./core.js */ \"./node_modules/promise/lib/core.js\");\n__webpack_require__(/*! ./done.js */ \"./node_modules/promise/lib/done.js\");\n__webpack_require__(/*! ./finally.js */ \"./node_modules/promise/lib/finally.js\");\n__webpack_require__(/*! ./es6-extensions.js */ \"./node_modules/promise/lib/es6-extensions.js\");\n__webpack_require__(/*! ./node-extensions.js */ \"./node_modules/promise/lib/node-extensions.js\");\n__webpack_require__(/*! ./synchronous.js */ \"./node_modules/promise/lib/synchronous.js\");\n\n\n//# sourceURL=webpack:///./node_modules/promise/lib/index.js?");

/***/ }),

/***/ "./node_modules/promise/lib/node-extensions.js":
/*!*****************************************************!*\
  !*** ./node_modules/promise/lib/node-extensions.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// This file contains then/promise specific extensions that are only useful\n// for node.js interop\n\nvar Promise = __webpack_require__(/*! ./core.js */ \"./node_modules/promise/lib/core.js\");\nvar asap = __webpack_require__(/*! asap */ \"./node_modules/asap/browser-asap.js\");\n\nmodule.exports = Promise;\n\n/* Static Functions */\n\nPromise.denodeify = function (fn, argumentCount) {\n  if (\n    typeof argumentCount === 'number' && argumentCount !== Infinity\n  ) {\n    return denodeifyWithCount(fn, argumentCount);\n  } else {\n    return denodeifyWithoutCount(fn);\n  }\n};\n\nvar callbackFn = (\n  'function (err, res) {' +\n  'if (err) { rj(err); } else { rs(res); }' +\n  '}'\n);\nfunction denodeifyWithCount(fn, argumentCount) {\n  var args = [];\n  for (var i = 0; i < argumentCount; i++) {\n    args.push('a' + i);\n  }\n  var body = [\n    'return function (' + args.join(',') + ') {',\n    'var self = this;',\n    'return new Promise(function (rs, rj) {',\n    'var res = fn.call(',\n    ['self'].concat(args).concat([callbackFn]).join(','),\n    ');',\n    'if (res &&',\n    '(typeof res === \"object\" || typeof res === \"function\") &&',\n    'typeof res.then === \"function\"',\n    ') {rs(res);}',\n    '});',\n    '};'\n  ].join('');\n  return Function(['Promise', 'fn'], body)(Promise, fn);\n}\nfunction denodeifyWithoutCount(fn) {\n  var fnLength = Math.max(fn.length - 1, 3);\n  var args = [];\n  for (var i = 0; i < fnLength; i++) {\n    args.push('a' + i);\n  }\n  var body = [\n    'return function (' + args.join(',') + ') {',\n    'var self = this;',\n    'var args;',\n    'var argLength = arguments.length;',\n    'if (arguments.length > ' + fnLength + ') {',\n    'args = new Array(arguments.length + 1);',\n    'for (var i = 0; i < arguments.length; i++) {',\n    'args[i] = arguments[i];',\n    '}',\n    '}',\n    'return new Promise(function (rs, rj) {',\n    'var cb = ' + callbackFn + ';',\n    'var res;',\n    'switch (argLength) {',\n    args.concat(['extra']).map(function (_, index) {\n      return (\n        'case ' + (index) + ':' +\n        'res = fn.call(' + ['self'].concat(args.slice(0, index)).concat('cb').join(',') + ');' +\n        'break;'\n      );\n    }).join(''),\n    'default:',\n    'args[argLength] = cb;',\n    'res = fn.apply(self, args);',\n    '}',\n    \n    'if (res &&',\n    '(typeof res === \"object\" || typeof res === \"function\") &&',\n    'typeof res.then === \"function\"',\n    ') {rs(res);}',\n    '});',\n    '};'\n  ].join('');\n\n  return Function(\n    ['Promise', 'fn'],\n    body\n  )(Promise, fn);\n}\n\nPromise.nodeify = function (fn) {\n  return function () {\n    var args = Array.prototype.slice.call(arguments);\n    var callback =\n      typeof args[args.length - 1] === 'function' ? args.pop() : null;\n    var ctx = this;\n    try {\n      return fn.apply(this, arguments).nodeify(callback, ctx);\n    } catch (ex) {\n      if (callback === null || typeof callback == 'undefined') {\n        return new Promise(function (resolve, reject) {\n          reject(ex);\n        });\n      } else {\n        asap(function () {\n          callback.call(ctx, ex);\n        })\n      }\n    }\n  }\n};\n\nPromise.prototype.nodeify = function (callback, ctx) {\n  if (typeof callback != 'function') return this;\n\n  this.then(function (value) {\n    asap(function () {\n      callback.call(ctx, null, value);\n    });\n  }, function (err) {\n    asap(function () {\n      callback.call(ctx, err);\n    });\n  });\n};\n\n\n//# sourceURL=webpack:///./node_modules/promise/lib/node-extensions.js?");

/***/ }),

/***/ "./node_modules/promise/lib/synchronous.js":
/*!*************************************************!*\
  !*** ./node_modules/promise/lib/synchronous.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar Promise = __webpack_require__(/*! ./core.js */ \"./node_modules/promise/lib/core.js\");\n\nmodule.exports = Promise;\nPromise.enableSynchronous = function () {\n  Promise.prototype.isPending = function() {\n    return this.getState() == 0;\n  };\n\n  Promise.prototype.isFulfilled = function() {\n    return this.getState() == 1;\n  };\n\n  Promise.prototype.isRejected = function() {\n    return this.getState() == 2;\n  };\n\n  Promise.prototype.getValue = function () {\n    if (this._V === 3) {\n      return this._W.getValue();\n    }\n\n    if (!this.isFulfilled()) {\n      throw new Error('Cannot get a value of an unfulfilled promise.');\n    }\n\n    return this._W;\n  };\n\n  Promise.prototype.getReason = function () {\n    if (this._V === 3) {\n      return this._W.getReason();\n    }\n\n    if (!this.isRejected()) {\n      throw new Error('Cannot get a rejection reason of a non-rejected promise.');\n    }\n\n    return this._W;\n  };\n\n  Promise.prototype.getState = function () {\n    if (this._V === 3) {\n      return this._W.getState();\n    }\n    if (this._V === -1 || this._V === -2) {\n      return 0;\n    }\n\n    return this._V;\n  };\n};\n\nPromise.disableSynchronous = function() {\n  Promise.prototype.isPending = undefined;\n  Promise.prototype.isFulfilled = undefined;\n  Promise.prototype.isRejected = undefined;\n  Promise.prototype.getValue = undefined;\n  Promise.prototype.getReason = undefined;\n  Promise.prototype.getState = undefined;\n};\n\n\n//# sourceURL=webpack:///./node_modules/promise/lib/synchronous.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),

/***/ "./src/MateMask.js":
/*!*************************!*\
  !*** ./src/MateMask.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("//èŽ·å–appç‰ˆæœ¬\nlet Promise = __webpack_require__(/*! promise */ \"./node_modules/promise/index.js\");\nvar EventEmitter = __webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter;\nvar event = new EventEmitter();\n\n\nlet Require = (paramJson) => {\n    console.log(\"Require be called\")\n    //TODO æ”¹å˜é’±åŒ…æ—¶éœ€è¦     event.emit(\"accountsChanged\",accounts: Array<string>)\n    //TODO æ”¹å˜é“¾æ—¶éœ€è¦     event.emit(\"chainChanged\",chainId: string)\n    //TODO é“¾æŽ¥æ—¶éœ€è¦     event.emit(\"connect\"ï¼Œinterface ConnectInfo {chainId: string;})\n    /*\n    interface ProviderRpcError extends Error {\n      message: string;\n      code: number;\n      data?: unknown;\n    }\n     */\n    //TODO æ–­å¼€é“¾æŽ¥æ—¶æ—¶éœ€è¦     event.emit(\"disconnect\",error: ProviderRpcError)\n    /*\n    interface ProviderMessage {\n      type: string;\n      data: unknown;\n    }\n     */\n    //TODO å‘é€ä¿¡æ¯æ—¶     event.emit(\"message\",message: ProviderMessage)\n    switch (paramJson.method){\n        case \"net_version\":\n            return new Promise(function (resolve, reject) {\n                var tpCallbackFun = _getCallbackName();\n                window[tpCallbackFun] = function (result) {\n                    result = result.replace(/\\r/ig, \"\").replace(/\\n/ig, \"\");\n                    try {\n                        let res = JSON.parse(result);\n                        resolve(res.result);\n                    } catch (e) {\n                        reject(e);\n                    }\n                }\n                _sendTpRequest('net_version', '', tpCallbackFun);\n            })\n            break;\n        case \"eth_chainId\":\n            return new Promise(function (resolve, reject) {\n                var tpCallbackFun = _getCallbackName();\n                window[tpCallbackFun] = function (result) {\n                    result = result.replace(/\\r/ig, \"\").replace(/\\n/ig, \"\");\n                    try {\n                        let res = JSON.parse(result)\n                        resolve(res.result);\n                    } catch (e) {\n                        reject(e);\n                    }\n                }\n                _sendTpRequest('eth_chainId', '', tpCallbackFun);\n            })\n            break;\n        case \"eth_accounts\":\n            return new Promise(function (resolve, reject) {\n                var tpCallbackFun = _getCallbackName();\n                window[tpCallbackFun] = function (result) {\n                    result = result.replace(/\\r/ig, \"\").replace(/\\n/ig, \"\");\n                    try {\n                        let res = JSON.parse(result);\n                        var str1 = new Array(res.result);\n                        resolve(str1);\n                    } catch (e) {\n                        reject(e);\n                    }\n                }\n                _sendTpRequest('eth_accounts', '', tpCallbackFun);\n            })\n            break;    \n        case \"eth_sign\" :\n            return new Promise(function (resolve, reject) {\n                var tpCallbackFun = _getCallbackName();\n                window[tpCallbackFun] = function (result) {\n                    result = result.replace(/\\r/ig, \"\").replace(/\\n/ig, \"\");\n                    try {\n                        let res = JSON.parse(result);\n                        resolve(res);\n                    } catch (e) {\n                        reject(e);\n                    }\n                }\n                _sendTpRequest('eth_sign',  JSON.stringify(paramJson.params), tpCallbackFun);\n            })\n            break;        \n        case \"eth_requestAccounts\":\n            return new Promise(function (resolve, reject) {\n                var tpCallbackFun = _getCallbackName();\n                window[tpCallbackFun] = function (result) {\n                    result = result.replace(/\\r/ig, \"\").replace(/\\n/ig, \"\");\n                    try {\n                        let res = JSON.parse(result);\n                        resolve(res);\n                    } catch (e) {\n                        reject(e);\n                    }\n                }\n                _sendTpRequest('eth_requestAccounts', paramJson.params, tpCallbackFun);\n            })\n            break;\n\n        case \"eth_getEncryptionPublicKey\": \n            return new Promise(function (resolve, reject) {\n                var tpCallbackFun = _getCallbackName();\n                window[tpCallbackFun] = function (result) {\n                    result = result.replace(/\\r/ig, \"\").replace(/\\n/ig, \"\");\n                    try {\n                        let res = JSON.parse(result);\n                        resolve(res);\n                    } catch (e) {\n                        reject(e);\n                    }\n                }\n                _sendTpRequest('eth_getEncryptionPublicKey', JSON.stringify(paramJson.params), tpCallbackFun);\n            });\n            break;  \n        case \"eth_signTypedData\": \n            return new Promise(function (resolve, reject) {\n                var tpCallbackFun = _getCallbackName();\n                window[tpCallbackFun] = function (result) {\n                    result = result.replace(/\\r/ig, \"\").replace(/\\n/ig, \"\");\n                    try {\n                        let res = JSON.parse(result);\n                        resolve(res);\n                    } catch (e) {\n                        reject(e);\n                    }\n                }\n                _sendTpRequest('eth_signTypedData', JSON.stringify(paramJson.params), tpCallbackFun);\n            });\n            break; \n        case \"eth_signTypedData_v3\": \n            return new Promise(function (resolve, reject) {\n                var tpCallbackFun = _getCallbackName();\n                window[tpCallbackFun] = function (result) {\n                    result = result.replace(/\\r/ig, \"\").replace(/\\n/ig, \"\");\n                    try {\n                        let res = JSON.parse(result);\n                        resolve(res);\n                    } catch (e) {\n                        reject(e);\n                    }\n                }\n                _sendTpRequest('eth_signTypedData_v3', JSON.stringify(paramJson.params), tpCallbackFun);\n            });\n            break;  \n\n        case \"eth_signTypedData_v4\":\n            return new Promise(function (resolve, reject) {\n                var tpCallbackFun = _getCallbackName();\n                window[tpCallbackFun] = function (result) {\n                    result = result.replace(/\\r/ig, \"\").replace(/\\n/ig, \"\");\n                    try {\n                        let res = JSON.parse(result);\n                        resolve(res);\n                    } catch (e) {\n                        reject(e);\n                    }\n                }\n                _sendTpRequest('eth_signTypedData_v4', JSON.stringify(paramJson.params), tpCallbackFun);\n            });\n            break;\n        case \"wallet_getPermissions\": \n            return new Promise(function (resolve, reject) {\n                var tpCallbackFun = _getCallbackName();\n                window[tpCallbackFun] = function (result) {\n                    result = result.replace(/\\r/ig, \"\").replace(/\\n/ig, \"\");\n                    try {\n                        let res = JSON.parse(result);\n                        if(res.result == \"true\"){\n                            resolve([{\n                                \"parentCapability\": \"eth_accounts\",\n                                \"date\": \"date\"\n                              }]);\n                        }else{\n                            reject(new ProviderRpcError(\"deny\",4001,\"\"));\n                        }\n                        \n                    } catch (e) {\n                        reject(e);\n                    }\n                }\n                _sendTpRequest('wallet_getPermissions', JSON.stringify(paramJson.params), tpCallbackFun);\n            });\n            break;            \n        case \"wallet_requestPermissions\":\n            return new Promise(function (resolve, reject) {\n                var tpCallbackFun = _getCallbackName();\n                window[tpCallbackFun] = function (result) {\n                    result = result.replace(/\\r/ig, \"\").replace(/\\n/ig, \"\");\n                    try {\n                        let res = JSON.parse(result);\n                        resolve(res);\n                    } catch (e) {\n                        reject(e);\n                    }\n                }\n                _sendTpRequest('wallet_requestPermissions', JSON.stringify(paramJson.params), tpCallbackFun);\n            });\n            break;        \n\n        case \"eth_call\" :\n            return new Promise(function (resolve, reject) {\n                var tpCallbackFun = _getCallbackName();\n                window[tpCallbackFun] = function (result) {\n                    result = result.replace(/\\r/ig, \"\").replace(/\\n/ig, \"\");\n                    try {\n                        let res = JSON.parse(result);\n                        resolve(res);\n                    } catch (e) {\n                        reject(e);\n                    }\n                }\n                _sendTpRequest('eth_call', paramJson.params, tpCallbackFun);\n            })\n            break;\n\n        case \"eth_getBalance\" :\n            return new Promise(function (resolve, reject) {\n                var tpCallbackFun = _getCallbackName();\n                window[tpCallbackFun] = function (result) {\n                    result = result.replace(/\\r/ig, \"\").replace(/\\n/ig, \"\");\n                    try {\n                        let res = JSON.parse(result);\n                        resolve(res);\n                    } catch (e) {\n                        reject(e);\n                    }\n                }\n                _sendTpRequest('eth_getBalance', paramJson.params, tpCallbackFun);\n            })\n            break;\n\n        case \"eth_estimateGas\":\n            return new Promise(function (resolve, reject) {\n                var tpCallbackFun = _getCallbackName();\n                window[tpCallbackFun] = function (result) {\n                    result = result.replace(/\\r/ig, \"\").replace(/\\n/ig, \"\");\n                    try {\n                        let res = JSON.parse(result);\n                        resolve(res);\n                    } catch (e) {\n                        reject(e);\n                    }\n                }\n                _sendTpRequest('eth_estimateGas', paramJson.params, tpCallbackFun);\n            });\n            break;\n\n        case \"eth_sendTransaction\" :\n            return new Promise(function (resolve, reject) {\n                var tpCallbackFun = _getCallbackName();\n                window[tpCallbackFun] = function (result) {\n                    result = result.replace(/\\r/ig, \"\").replace(/\\n/ig, \"\");\n                    try {\n                        let res = JSON.parse(result);\n                        resolve(res);\n                    } catch (e) {\n                        reject(e);\n                    }\n                }\n                _sendTpRequest('eth_sendTransaction', JSON.stringify(paramJson.params), tpCallbackFun);\n            })\n            break;\n        case\"wallet_scanQRCode\":\n            return new Promise(function (resolve, reject) {\n                var tpCallbackFun = _getCallbackName();\n                window[tpCallbackFun] = function (result) {\n                    result = result.replace(/\\r/ig, \"\").replace(/\\n/ig, \"\");\n                    try {\n                        let res = JSON.parse(result);\n                        resolve(res);\n                    } catch (e) {\n                        reject(e);\n                    }\n                }\n                _sendTpRequest('wallet_scanQRCode', paramJson.params, tpCallbackFun);\n            })\n            break;\n\n        case \"wallet_watchAsset\":\n            return new Promise(function (resolve, reject) {\n                var tpCallbackFun = _getCallbackName();\n                window[tpCallbackFun] = function (result) {\n                    result = result.replace(/\\r/ig, \"\").replace(/\\n/ig, \"\");\n                    try {\n                        let res = JSON.parse(result);\n                        resolve(res);\n                    } catch (e) {\n                        reject(e);\n                    }\n                }\n                _sendTpRequest('wallet_watchAsset', paramJson.params, tpCallbackFun);\n            })\n            break;\n        case \"wallet_addEthereumChain\":\n            return new Promise(function (resolve, reject) {\n                var tpCallbackFun = _getCallbackName();\n                window[tpCallbackFun] = function (result) {\n                    result = result.replace(/\\r/ig, \"\").replace(/\\n/ig, \"\");\n                    try {\n                        let res = JSON.parse(result);\n                        resolve(res);\n                    } catch (e) {\n                        reject(e);\n                    }\n                }\n                _sendTpRequest('wallet_addEthereumChain', paramJson.params, tpCallbackFun);\n            })\n            break;\n        case \"personal_sign\": \n            return new Promise(function (resolve, reject) {\n                var tpCallbackFun = _getCallbackName();\n                window[tpCallbackFun] = function (result) {\n                    result = result.replace(/\\r/ig, \"\").replace(/\\n/ig, \"\");\n                    try {\n                        let res = JSON.parse(result);\n                        resolve(res);\n                    } catch (e) {\n                        reject(e);\n                    }\n                }\n                _sendTpRequest('personal_sign', JSON.stringify(paramJson.params), tpCallbackFun);\n            });\n            break;\n\n        default:console.log(\"è¿™ä¸ªæ–¹æ³•åœ¨ ä¸­é—´ä»¶ä¸­æ²¡æœ‰å®šä¹‰  \"+paramJson.method);\n    }\n}\n\nlet on = (method,callback) =>{\n    event.on(method, callback);\n}\n\nfun();\nfunction fun(){\n    if(window.ethereum!=null&&typeof(window.ethereum)!=\"undefined\"){\n        window.ethereum.isConnected = function (){\n            return true;\n        }\n        window.ethereum.request = Require\n        window.ethereum.isMetaMask = true\n        window.ethereum.on = on\n        console.log(\"api init over\")\n    }else{\n        console.log(\"api init failed\")\n    }\n    console.log(\"ok\")\n    event.emit('chainChanged', '12')\n    event.emit('networkChanged', '123')\n    event.emit('accountsChanged', '1234')\n}\n\nfunction _getCallbackName() {\n    var ramdom = parseInt(Math.random() * 100000);\n    return 'tp_callback_' + new Date().getTime() + ramdom;\n}\n\nfunction _sendTpRequest (methodName, params, callback) {\n    if (window.ethereum) {\n        window.ethereum.callHandler(methodName, params, callback);\n    }\n}\n\nfunction _getTypeByStr (typeStr) {\n    var reTrim = /^\\s+|\\s+$/g;\n    typeStr += '';\n    typeStr = typeStr.replace(reTrim, '').toLowerCase();\n    return TYPE_MAP[typeStr] || typeStr;\n}\n\nfunction Interface(name,methods){ // æŽ¥å£è¾…åŠ©ç±»ï¼Œå‚æ•°åŒ…æ‹¬æŽ¥å£å®žä¾‹çš„åç§°å’Œæ–¹æ³•é›†\n    if(arguments.length!=2){ // å¦‚æžœå‚æ•°ä¸ªæ•°ä¸ç­‰äºŽ2ï¼ŒæŠ›å‡ºå¼‚å¸¸ã€‚\n      throw new Error('æ ‡å‡†æŽ¥å£çº¦å®šï¼Œéœ€è¦ä¸¤ä¸ªå‚æ•°');\n    }\n    this.name = name; // å­˜å‚¨ç¬¬ä¸€ä¸ªå‚æ•°å€¼ï¼Œå®žä¾‹åŒ–åŽå°±æ˜¯æŽ¥å£å®žä¾‹çš„åç§°\n    this.methods = []; // æŽ¥å£å®žä¾‹çš„æ–¹æ³•å­˜å‚¨å™¨\n    if(methods.length < 1){ // å¦‚æžœç¬¬äºŒä¸ªå‚æ•°çš„å…ƒç´ ä¸ªæ•°ä¸º0ï¼Œè¯´æ˜Žæ˜¯ç©ºæ•°ç»„ï¼ŒæŠ›å‡ºå¼‚å¸¸ã€‚\n      throw new Error('æŽ¥å£çš„ç¬¬äºŒä¸ªå‚æ•°ä¸èƒ½ä¸ºç©º');\n    }\n    for(var i = 0; i < methods.length; i++){ // å¼€å§‹å¯¹ç¬¬2ä¸ªå‚æ•°çš„å…ƒç´ è¿›è¡ŒéåŽ†æ£€æµ‹\n      var item = methods[i];\n      if(typeof item[0] !== 'string') { // å¦‚æžœç¬¬äºŒä¸ªå‚æ•°çš„ç¬¬ä¸€ä¸ªå…ƒç´ ä¸æ˜¯stringç±»åž‹ï¼ŒæŠ›å‡ºå¼‚å¸¸\n        throw new Error(\"æŽ¥å£çº¦å®šçš„ç¬¬ä¸€ä¸ªå‚æ•°åº”ä¸ºå­—ç¬¦ä¸²\");\n      }\n      if(item[1]&&typeof item[1] !== 'number'){ // å¦‚æžœç¬¬äºŒä¸ªå‚æ•°æœ‰ç¬¬äºŒä¸ªå…ƒç´ ï¼Œä¸”ç¬¬äºŒä¸ªå…ƒç´ ä¸æ˜¯numberç±»åž‹ï¼ŒæŠ›å‡ºå¼‚å¸¸\n        throw new Error('æŽ¥å£çº¦å®šçš„ç¬¬ä¸ªå‚æ•°åº”ä¸ºæ•°å€¼');\n      }\n      if(item.length == 1){ // å¦‚æžœç¬¬äºŒä¸ªå‚æ•°åªæœ‰ä¸€ä¸ªå…ƒç´ ï¼Œé‚£ä¹ˆæ‰‹åŠ¨ç»™å®ƒæ·»åŠ ç¬¬äºŒä¸ªå…ƒç´  0\n        item[1] = 0;\n      }\n      this.methods.push(item); // æŠŠç¬¦åˆè§„å®šçš„æ–¹æ³•å­˜å‚¨åˆ°æ•°ç»„å­˜å‚¨å™¨ä¸­ã€‚\n    }\n  }\n  Interface.implements = function(o){  // ç”¨äºŽæ£€æµ‹ç±»æ–¹æ³•æ˜¯å¦ç¬¦åˆæŽ¥å£å®žä¾‹çš„çº¦å®š ï¼Œæ­¤å¤„çš„o,å°†æ¥ä¼šæ˜¯ç±»ä¸­çš„this\n    if(arguments.length<2){ // æ£€æµ‹è¯¥æ–¹æ³•ä¼ é€’çš„æ•°å€¼æ˜¯å¦ç¬¦åˆè§„å®š\n      throw new Error(\"æŽ¥å£çº¦å®šç±»åº”åŒ…å«è‡³å°‘ä¸¤ä¸ªå‚æ•°ã€‚\");\n    }\n    for(var i=1;i<arguments.length; i++){ // éåŽ†æ£€æµ‹ç±»æ‰€éµå¾ªçš„å®žä¾‹æ˜¯å¦åˆæ³•\n      var interface = arguments[i]; // è¿™é‡Œinterfaceè¡¨ç¤ºæŽ¥å£çš„å®žä¾‹å¯¹è±¡ã€‚\n      if(interface.constructor !== Interface){\n        throw new Error('ä»Žç¬¬2ä¸ªä»¥ä¸Šçš„å‚æ•°å¿…é¡»ä¸ºæŽ¥å£å®žä¾‹');\n      }\n      for(var j=0;j<interface.methods.length;j++){ // æ£€æµ‹ç±»æ–¹æ³•æ˜¯å¦ç¬¦åˆæŽ¥å£å®žä¾‹çš„çº¦å®š\n        var method = interface.methods[j][0];\n        if(!o[method] || typeof o[method] !== 'function' || o[method].length!==interface.methods[j][1]) {\n          throw new Error(\"è¯¥å®žçŽ°ç±»æ²¡èƒ½å±¥è¡Œ\" + interface.name + \"æŽ¥å£æ–¹æ³•\" + method + \"çº¦å®š\");\n        }\n      }\n    }\n  }\nInterface.ensureImplements = function(object){\n    if(arguments.length<2){\n        throw new Error('arguments at lest 2');\n    }\n    for(var i =1; i< arguments.length;i++){\n        var interfacetmp = arguments[i];\n        if(interfacetmp.constructor !== Interface){\n            throw new Error('not Interface');\n        }\n        for(j=0;j<interfacetmp.methods.length;j++){\n            var method = interfacetmp.methods[j];\n            if(!object[method] || typeof object[method] != 'function'){\n                throw new Error(method+'æ²¡æœ‰å®žçŽ°æŽ¥å£æ–¹æ³•');\n            }\n        }\n    }\n}\n\nvar web3WalletPermission = new Interface(\"web3WalletPermission\",[[\"parentCapability\",1],[\"date\",1]]);\n\nfunction Web3WalletPermission(){\n    Interface.implements(this,web3WalletPermission);\n   }\n   Web3WalletPermission.prototype.parentCapability = function(){\n    return \"eth_accounts\";\n   }\n   Web3WalletPermission.prototype.date = function(name){\n    return \"code\"\n}\n\n\nclass ProviderRpcError extends Error {\n    constructor(message,code,data) {\n        super(message)\n        this.code = code;\n        this.data = data;\n        this.name = \"ValidationError\";\n      }\n}\n\n\n\n\n\n//# sourceURL=webpack:///./src/MateMask.js?");

/***/ })

/******/ });